package saros.activities;

import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamAsAttribute;
import org.apache.commons.lang3.ObjectUtils;
import saros.session.User;

/**
 * @JTourBusStop 3, StopManager:
 *
 * <p>The StopActivity is created by the StopManager#stop() method, it contains the kind of request
 * and the #user that should be stopped.
 */
/**
 * A StopActivity is used for signaling to a user that he should be stopped or started (meaning that
 * no more Activities should be generated by this user).
 */
@XStreamAlias("stopActivity")
public class StopActivity extends AbstractActivity implements ITargetedActivity {

  public enum Type {
    LOCKREQUEST,
    UNLOCKREQUEST
  }

  public enum State {
    INITIATED,
    ACKNOWLEDGED
  }

  @XStreamAsAttribute protected User initiator;

  /** The user who has to be locked / unlocked. */
  @XStreamAsAttribute protected final User affected;

  @XStreamAsAttribute protected final Type type;

  @XStreamAsAttribute protected final State state;

  /** A stop activity has a unique ID. */
  @XStreamAsAttribute protected final String stopActivityID;

  /**
   * @param source
   * @param initiator The user who requested the lock/unlock (in most cases this should be the host)
   * @param affected The user to be locked/unlocked by this Activity
   * @param type
   * @param state
   * @param stopActivityID
   */
  public StopActivity(
      User source, User initiator, User affected, Type type, State state, String stopActivityID) {

    super(source);

    if (initiator == null) throw new IllegalArgumentException("initiator must not be null");
    if (affected == null) throw new IllegalArgumentException("affected must not be null");

    this.initiator = initiator;
    this.affected = affected;
    this.state = state;
    this.type = type;
    this.stopActivityID = stopActivityID;
  }

  @Override
  public boolean isValid() {
    return super.isValid() && (initiator != null) && (affected != null);
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ObjectUtils.hashCode(initiator);
    result = prime * result + ObjectUtils.hashCode(state);
    result = prime * result + ObjectUtils.hashCode(stopActivityID);
    result = prime * result + ObjectUtils.hashCode(type);
    result = prime * result + ObjectUtils.hashCode(affected);
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) return true;
    if (!super.equals(obj)) return false;
    if (!(obj instanceof StopActivity)) return false;

    StopActivity other = (StopActivity) obj;

    if (this.state != other.state) return false;
    if (this.type != other.type) return false;
    if (!ObjectUtils.equals(this.stopActivityID, other.stopActivityID)) return false;
    if (!ObjectUtils.equals(this.initiator, other.initiator)) return false;
    if (!ObjectUtils.equals(this.affected, other.affected)) return false;

    return true;
  }

  /** The user to be locked/unlocked by this Activity */
  public User getAffected() {
    return affected;
  }

  /**
   * The user who requested the lock/unlock.
   *
   * <p>(in most cases this should be the host)
   */
  public User getInitiator() {
    return initiator;
  }

  /**
   * Returns the JID of the user to whom this StopActivity should be sent.
   *
   * <p>This method is a convenience method for getting the affected user or initiator based on the
   * state of this StopActivity.
   */
  public User getRecipient() {
    switch (getState()) {
      case INITIATED:
        return getAffected();
      case ACKNOWLEDGED:
        return getInitiator();
      default:
        throw new IllegalStateException(
            "StopActivity is in an illegal state to return a recipient");
    }
  }

  @Override
  public User getTarget() {
    return getRecipient();
  }

  public State getState() {
    return state;
  }

  public StopActivity generateAcknowledgment(User source) {
    return new StopActivity(source, initiator, affected, type, State.ACKNOWLEDGED, stopActivityID);
  }

  public Type getType() {
    return type;
  }

  public String getActivityID() {
    return stopActivityID;
  }

  @Override
  public String toString() {
    return "StopActivity(id: "
        + stopActivityID
        + ", type: "
        + type
        + ", state: "
        + state
        + ", initiator: "
        + initiator
        + ", affected user: "
        + affected
        + ", src: "
        + getSource()
        + ")";
  }

  @Override
  public void dispatch(IActivityReceiver receiver) {
    receiver.receive(this);
  }
}
